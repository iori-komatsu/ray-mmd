////////////////////////////////////////////////////////////////////////////////////////////

// Code from by inigo quilez - iq/2016
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
// https://www.shadertoy.com/view/4ttSWf

//==========================================================================================
// hashes
//==========================================================================================

float hash1(float2 p) {
    p  = 50.0*frac( p*0.3183099 );
    return frac( p.x*p.y*(p.x+p.y) );
}

float hash1(float n) {
    return frac( n*17.0*frac( n*0.3183099 ) );
}

float2 hash2(float n) {
	return frac(sin(float2(n,n+1.0))*float2(43758.5453123,22578.1459123));
}


float2 hash2(float2 p) {
    const float2 k = float2(0.3183099, 0.3678794);
    p = p*k + k.yx;
    return frac( 16.0 * k*frac( p.x*p.y*(p.x+p.y)) );
}

//==========================================================================================
// noises
//==========================================================================================

// value noise, and its analytical derivatives
float4 noised(in float3 x) {
    float3 p = floor(x);
    float3 w = frac(x);
    
    float3 u = w*w*w*(w*(w*6.0-15.0)+10.0);
    float3 du = 30.0*w*w*(w*(w-2.0)+1.0);

    float n = p.x + 317.0*p.y + 157.0*p.z;
    
    float a = hash1(n+0.0);
    float b = hash1(n+1.0);
    float c = hash1(n+317.0);
    float d = hash1(n+318.0);
    float e = hash1(n+157.0);
	float f = hash1(n+158.0);
    float g = hash1(n+474.0);
    float h = hash1(n+475.0);

    float k0 =   a;
    float k1 =   b - a;
    float k2 =   c - a;
    float k3 =   e - a;
    float k4 =   a - b - c + d;
    float k5 =   a - c - e + g;
    float k6 =   a - b - e + f;
    float k7 = - a + b + c - d + e - f - g + h;

    return float4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), 
                        2.0* du * float3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,
                                          k2 + k5*u.z + k4*u.x + k7*u.z*u.x,
                                          k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );
}

float noise( in float3 x )
{
    float3 p = floor(x);
    float3 w = frac(x);
    
    float3 u = w*w*w*(w*(w*6.0-15.0)+10.0);
    
    float n = p.x + 317.0*p.y + 157.0*p.z;
    
    float a = hash1(n+0.0);
    float b = hash1(n+1.0);
    float c = hash1(n+317.0);
    float d = hash1(n+318.0);
    float e = hash1(n+157.0);
	float f = hash1(n+158.0);
    float g = hash1(n+474.0);
    float h = hash1(n+475.0);

    float k0 =   a;
    float k1 =   b - a;
    float k2 =   c - a;
    float k3 =   e - a;
    float k4 =   a - b - c + d;
    float k5 =   a - c - e + g;
    float k6 =   a - b - e + f;
    float k7 = - a + b + c - d + e - f - g + h;

    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);
}

float3 noised(in float2 x) {
    float2 p = floor(x);
    float2 w = frac(x);
    
    float2 u = w*w*w*(w*(w*6.0-15.0)+10.0);
    float2 du = 30.0*w*w*(w*(w-2.0)+1.0);
    
    float a = hash1(p+float2(0,0));
    float b = hash1(p+float2(1,0));
    float c = hash1(p+float2(0,1));
    float d = hash1(p+float2(1,1));

    float k0 = a;
    float k1 = b - a;
    float k2 = c - a;
    float k4 = a - b - c + d;

    return float3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), 
                        2.0* du * float2( k1 + k4*u.y,
                                          k2 + k4*u.x ) );
}

float noise(in float2 x) {
    float2 p = floor(x);
    float2 w = frac(x);
    float2 u = w*w*w*(w*(w*6.0-15.0)+10.0);
    
#if 0
    p *= 0.3183099;
    float kx0 = 50.0*frac( p.x );
    float kx1 = 50.0*frac( p.x+0.3183099 );
    float ky0 = 50.0*frac( p.y );
    float ky1 = 50.0*frac( p.y+0.3183099 );

    float a = frac( kx0*ky0*(kx0+ky0) );
    float b = frac( kx1*ky0*(kx1+ky0) );
    float c = frac( kx0*ky1*(kx0+ky1) );
    float d = frac( kx1*ky1*(kx1+ky1) );
#else
    float a = hash1(p+float2(0,0));
    float b = hash1(p+float2(1,0));
    float c = hash1(p+float2(0,1));
    float d = hash1(p+float2(1,1));
#endif
    
    return -1.0+2.0*( a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y );
}

//==========================================================================================
// fbm constructions
//==========================================================================================

const float3x3 m3  = float3x3( 0.00,  0.80,  0.60,
                              -0.80,  0.36, -0.48,
                              -0.60, -0.48,  0.64 );
const float3x3 m3i = float3x3( 0.00, -0.80, -0.60,
                               0.80,  0.36, -0.48,
                               0.60, -0.48,  0.64 );
const float2x2 m2 = float2x2(  0.80,  0.60,
                              -0.60,  0.80 );
const float2x2 m2i = float2x2( 0.80, -0.60,
                               0.60,  0.80 );

//------------------------------------------------------------------------------------------

float fbm_4(in float3 x) {
    float f = 2.0;
    float s = 0.5;
    float a = 0.0;
    float b = 0.5;
    for(int i=0; i<4; i++) {
        float n = noise(x);
        a += b*n;
        b *= s;
        x = f*mul(m3, x);
    }
	return a;
}

float4 fbmd_8(in float3 x) {
    float f = 1.92;
    float s = 0.5;
    float a = 0.0;
    float b = 0.5;
    float3   d = float3(0.0,0.0,0.0);
    float3x3 m = float3x3(1.0,0.0,0.0,
                          0.0,1.0,0.0,
                          0.0,0.0,1.0);
    for(int i=0; i<7; i++) {
        float4 n = noised(x);
        a += b*n.x;           // accumulate values		
        d += b*mul(m, n.yzw); // accumulate derivatives
        b *= s;
        x = f*mul(m3, x);
        m = f*mul(m3i, m);
    }
	return float4(a, d);
}

float fbm_9(in float2 x) {
    float f = 1.9;
    float s = 0.55;
    float a = 0.0;
    float b = 0.5;
    for(int i=0; i<9; i++) {
        float n = noise(x);
        a += b*n;
        b *= s;
        x = f*mul(m2, x);
    }
	return a;
}

float3 fbmd_9(in float2 x) {
    float f = 1.9;
    float s = 0.55;
    float a = 0.0;
    float b = 0.5;
    float2   d = float2(0.0,0.0);
    float2x2 m = float2x2(1.0,0.0,0.0,1.0);
    for(int i=0; i<9; i++) {
        float3 n = noised(x);
        a += b*n.x;          // accumulate values		
        d += b*mul(m, n.yz); // accumulate derivatives
        b *= s;
        x = f*mul(m2, x);
        m = f*mul(m2i, m);
    }
	return float3(a, d);
}

float fbm_4(in float2 x) {
    float f = 1.9;
    float s = 0.55;
    float a = 0.0;
    float b = 0.5;
    for(int i=0; i<4; i++) {
        float n = noise(x);
        a += b*n;
        b *= s;
        x = f*mul(m2, x);
    }
	return a;
}

////////////////////////////////////////////////////////////////////////////////////////////

// 二次方程式 ax^2 + bx + c = 0 の解を求める
float2 SolveQuadraticEquation(float a, float b, float c, out float disc) {
	disc = b*b - 4*a*c;
	float sd = sqrt(disc);
	return float2((-b-sd)/(2*a), (-b+sd)/(2*a));
}

// レイと原点を中心とする球の交点を求める
float3 RaySphereIntersection(float3 rayPos, float3 rayDir, float sphereRadius, out bool hit) {
	float disc;
	float2 s = SolveQuadraticEquation(
		dot(rayDir, rayDir),
		2*dot(rayPos, rayDir),
		dot(rayPos, rayPos) - sphereRadius*sphereRadius,
		disc
	);
	if (disc < 0) {
		hit = false;
		return float3(0, 0, 0);
	}

	float t;
	if (s.x >= 0) {
		t = s.x;
	} else if (s.y >= 0) {
		t = s.y;
	} else {
		hit = false;
		return float3(0, 0, 0);
	}

	hit = true;
	return float3(rayPos + t*rayDir);
}

// レイと平面と交点を求める
float3 RayPlaneIntersection(float3 rayPos, float3 rayDir, float3 planePoint, float3 planeNormal, out bool hit) {
	float denom = dot(rayDir, planeNormal);
	if (abs(denom) < EPSILON) {
		hit = false;
		return float3(0, 0, 0);
	}
	float t = dot(planePoint - rayPos, planeNormal) / denom;
	if (t < 0) {
		hit = false;
		return float3(0, 0, 0);
	}
	hit = true;
	return rayPos + t*rayDir;
}

float IK_SphereFunction(float3 p, float r) {
	return length(p) - r;
}

float3 IK_Normal(float3 p, float r) {
	float eps = 0.0001;

	float d0 = IK_SphereFunction(p, r);
	float dx = IK_SphereFunction(p + float3(-eps, 0, 0), r);
	float dy = IK_SphereFunction(p + float3(0, -eps, 0), r);
	float dz = IK_SphereFunction(p + float3(0, 0, -eps), r);

	return normalize(float3(d0 - dx, d0 - dy, d0 - dz));
}

float4 Iori_PostEffectExampleVS(
	in float4 Position : POSITION,
	in float4 Texcoord : TEXCOORD,
	out float4 oTexcoord0 : TEXCOORD0) : POSITION
{
	oTexcoord0 = Texcoord;
	oTexcoord0.xy += ViewportOffset;
	oTexcoord0.zw = oTexcoord0.xy * ViewportSize;
	return Position;
}

float OpticalDepthAt(float3 p, float sphereRadius) {
	float u = length(p) / sphereRadius;
	float densityLo = 0.5;
	float densityHi = 1.0;
	float density = (fbm_4(p) * 0.5 + 0.5) * lerp(densityLo, densityHi, u*u);
	return log(density + EPSILON);
}

float CastRay(
	float3 rayPos,
	float3 rayDir,
	float3 cameraDir,
	float sphereRadius,
	out float3 surfacePos
) {
	bool willHit;
	surfacePos = RaySphereIntersection(rayPos, rayDir, sphereRadius, willHit);
	if (!willHit)  {
		return -1;
	}

	static const int N_LAYERS = 5;
	float3 firstLayerPoint = -cameraDir * sphereRadius;
	float3 layerInterval = sphereRadius / (N_LAYERS - 1);

	float opticalDepth = 0;

	for (int i = 0; i < N_LAYERS; i++) {
		// レイがi番目のレイヤーとぶつかる点を求める
		float3 layerPoint = firstLayerPoint + (i * layerInterval) * cameraDir;
		float3 ithPoint = RayPlaneIntersection(rayPos, rayDir, layerPoint, cameraDir, willHit);

		// 球の内側であれば光学的深さを加算する
		if (IK_SphereFunction(ithPoint, sphereRadius) < EPSILON) {
			opticalDepth += OpticalDepthAt(ithPoint, sphereRadius);
		}
	}

	return exp(opticalDepth);
}

float4 Iori_PostEffectExamplePS(
	in float4 coord : TEXCOORD0,
	uniform sampler source) : COLOR
{
	float4 MRT0 = tex2Dlod(Gbuffer5Map, float4(coord.xy, 0, 0));
	float4 MRT1 = tex2Dlod(Gbuffer6Map, float4(coord.xy, 0, 0));
	float4 MRT2 = tex2Dlod(Gbuffer7Map, float4(coord.xy, 0, 0));
	float4 MRT3 = tex2Dlod(Gbuffer8Map, float4(coord.xy, 0, 0));

	MaterialParam material;
	DecodeGbuffer(MRT0, MRT1, MRT2, MRT3, material);

	float2 p = (coord.xy - 0.5) * 2.0;
	float3 rayDir =
		  matView._13_23_33 / matProject._33
		+ matView._11_21_31 * p.x / matProject._11
		- matView._12_22_32 * p.y / matProject._22;
	rayDir = normalize(rayDir);
	float3 rayPos = CameraPosition;

	float3 cameraDir = normalize(matView._13_23_33 / matProject._33);

	float sphereRadius = 10.0;

	float3 surfacePos;
	float alpha = CastRay(rayPos, rayDir, cameraDir, sphereRadius, surfacePos);

	clip(alpha); // オブジェクトに衝突していない場合は描画しない

	float d = distance(rayPos, surfacePos);
	float depth = dot(cameraDir, d * rayDir);
	clip(material.linearDepth - depth);

	// 色を計算する
	//float3 normal = IK_Normal(surfacePos, sphereRadius);
	//float c = fbm_4(surfacePos) * 0.5 + 0.5;
	//float diffuse = dot(normal, -SunDirection) * c;
	return float4(0.0, 0.0, 0.0, 1.0 - alpha);
}

/*
// 1 output, 3 inputs
float Hash13(float3 p) {
	p = float3(
		dot(p, float3(127.1,311.7, 74.7)),
		dot(p, float3(269.5,183.3,246.1)),
		dot(p, float3(113.5,271.9,124.6))
	);
	return frac(sin(p) * 43758.5453123);
}

float ValueNoise(float3 p) {
	float3 i = floor(p);
	float3 f = frac(p);

	float v0 = Hash13(i + float3(0, 0, 0));
	float v1 = Hash13(i + float3(1, 0, 0));
	float v2 = Hash13(i + float3(0, 1, 0));
	float v3 = Hash13(i + float3(1, 1, 0));
	float v4 = Hash13(i + float3(0, 0, 1));
	float v5 = Hash13(i + float3(1, 0, 1));
	float v6 = Hash13(i + float3(0, 1, 1));
	float v7 = Hash13(i + float3(1, 1, 1));

	float3 alpha = smoothstep(0.0, 1.0, f);

	return lerp(
		lerp(
			lerp(v0, v1, alpha.x),
			lerp(v2, v3, alpha.x),
			alpha.y
		),
		lerp(
			lerp(v4, v5, alpha.x),
			lerp(v6, v7, alpha.x),
			alpha.y
		),
		alpha.z
	);
}

float FBM(float3 p) {
	float v = 0.0;
	v += 1.0 * ValueNoise(p / 1.0);
	v += 2.0 * ValueNoise(p / 2.0);
	v += 4.0 * ValueNoise(p / 4.0);
	v += 8.0 * ValueNoise(p / 8.0);
	return v / (1 + 2 + 4 + 8);
}

float4 Iori_SobelPS(
	in float2 coord : TEXCOORD0,
	in float3 viewdir : TEXCOORD1,
	uniform sampler source) : COLOR
{
	float c;
	float2 p;
	float2 g = float2(0, 0);

	#define CONVOLVE(offsetX, offsetY, coeffX, coeffY) \
		p = coord + float2(offsetX, offsetY) * ViewportOffset2; \
		c = tex2Dlod(source, float4(p, 0, 0)).rgb; \
		g += length(c) * float2(coeffX, coeffY);

	CONVOLVE(-1, -1,  1,  1)
	CONVOLVE( 0, -1,  0,  2)
	CONVOLVE( 1, -1, -1,  1)
	CONVOLVE(-1,  0,  2,  0)
	CONVOLVE( 0,  0,  0,  0)
	CONVOLVE( 1,  0, -2,  0)
	CONVOLVE(-1,  1,  1, -1)
	CONVOLVE( 0,  1,  0, -2)
	CONVOLVE( 1,  1, -1, -1)

	#undef CONVOLVE

	float3 color = length(g);
	return float4(color, 1.0);
}
*/