#ifndef GATAGATA_EX_INCLUDED
#define GATAGATA_EX_INCLUDED

#ifndef PI
    #define PI 3.1415926535
#endif

//-------------------------------------------------------------------------------------------------

float3 mCenter : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "Center";>;
float3 mSize   : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "Size";>;
float3 mYmin   : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "Ymin";>;
float3 mYmax   : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "Ymax";>;

static const float PlaneSize = abs(mSize.x) * 2;
static const int HitTextureSize = 512;
static const float2 HitTextureOffset = float2(0.5, 0.5) / HitTextureSize;

// ビュー行列を返す。
// eye: カメラの座標
// at: カメラの注目点の座標
// up: カメラの上方向を表すベクトル
float4x4 MatrixLookAtLH(float3 eye, float3 at, float3 up) {
    float3 zaxis = normalize(at - eye);
    float3 xaxis = normalize(cross(up, zaxis));
    float3 yaxis = cross(zaxis, xaxis);
    return float4x4(
                 xaxis.x,          yaxis.x,          zaxis.x,    0,
                 xaxis.y,          yaxis.y,          zaxis.y,    0,
                 xaxis.z,          yaxis.z,          zaxis.z,    0,
        -dot(xaxis, eye), -dot(yaxis, eye), -dot(zaxis, eye),    1
	);
}

// 正射影行列を返す。
// w: ビューボリュームの幅
// h: ビューボリュームの高さ
// zn: 近クリップ平面の z 値
// zf: 遠クリップ平面の z 値
float4x4 MatrixOrthoLH(float w, float h, float zn, float zf) {
    return float4x4 (
        2/w,   0,          0,    0,
          0, 2/h,          0,    0,
          0,   0,  1/(zf-zn),    0,
          0,   0, zn/(zn-zf),    1
	);
}

static const float4x4 HitTestViewMatrix = MatrixLookAtLH(
	mCenter, mCenter + float3(0, 1, 0), float3(0, 0, 1)
);
static const float4x4 HitTestProjMatrix = MatrixOrthoLH(
	PlaneSize, PlaneSize, min(mYmin.y, mYmax.y), max(mYmin.y, mYmax.y)
);
static const float4x4 HitTestViewProjMatrix = mul(HitTestViewMatrix, HitTestProjMatrix);

inline float4 WorldPosToHitTexturePos(float4 worldPos) {
    return mul(worldPos, HitTestViewProjMatrix);
}

//-------------------------------------------------------------------------------------------------

#ifndef HIT_TEST_ONLY

float3 mPerturbWidth      : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "PerturbWidth";>;
float mPerturbPeriodP     : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "PerturbPeriod+";>;
float mPerturbPeriodM     : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "PerturbPeriod-";>;
float mDistortionPeriodP  : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "DistortionPeriod+";>;
float mDistortionPeriodM  : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "DistortionPeriod-";>;
float mYCompressionP      : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "YCompression+";>;
float mYCompressionM      : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "YCompression-";>;
float mYVarianceP         : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "YVariance+";>;
float mYVarianceM         : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "YVariance-";>;
float mDistortionAngleP   : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "DistortionAngle+";>;
float mDistortionAngleM   : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "DistortionAngle-";>;
float mAmbientLightP      : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "AmbientLight+";>;
float mAmbientLightM      : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "AmbientLight-";>;
float mReduceLight        : CONTROLOBJECT<string name = "GatagataExController.pmx"; string item = "ReduceLight";>;

static const float PerturbMaxWidth = mPerturbWidth.x;
static const float PerturbFrequency = 1.0 / lerp(lerp(0.1, 30, mPerturbPeriodP), 0.001, mPerturbPeriodM);
static const float YScalingMin = 1.0 - lerp(lerp(0.25, 0.995, mYCompressionP), 0.0, mYCompressionM);
static const float YScalingMax = lerp(YScalingMin, 1.0, lerp(lerp(0.5, 1.0, mYVarianceP), 0.0, mYVarianceM));
static const float NormalDistortionFrequency = 1.0 / lerp(lerp(10, 100, mDistortionPeriodP), 0.5, mDistortionPeriodM);
static const float NormalDistortionMaxAngle = lerp(lerp(0.3, 1.0, mDistortionAngleP), 0.0, mDistortionAngleM);
//static const float AmbientCoeff = lerp(lerp(0.2, 1.0, mAmbientLightP), 0.0, mAmbientLightM);
static const float HitThreshold = 0.1;

shared texture2D HitHistory : RENDERCOLORTARGET;
sampler HitHistorySampler = sampler_state {
    Texture = (HitHistory);
    MAGFILTER = LINEAR;
    MINFILTER = LINEAR;
    MIPFILTER = LINEAR;
    ADDRESSU = BORDER;
    ADDRESSV = BORDER;
};

float  hash(float  v) { return frac(sin(v * 78.233) * 43758.5453123); }
float2 hash(float2 v) { return frac(sin(v * 78.233) * 43758.5453123); }
float3 hash(float3 v) { return frac(sin(v * 78.233) * 43758.5453123); }
float4 hash(float4 v) { return frac(sin(v * 78.233) * 43758.5453123); }

float hash12(float2 v)
{
	float2 e;
	v = frexp(v, e);
	v += e * (1.0 / 129.0);
	return hash(hash(v.x) + v.y);
}

float hash13(float3 v)
{
	float3 e;
	v = frexp(v, e);
	v += e * (1.0 / 129.0);
	return hash(hash(hash(v.x) + v.y) + v.z);
}

float3 hash33(float3 v)
{
	float3 e;
	v = frexp(v, e);
	v += e * (1.0 / 129.0);
	return hash(hash(hash(v.x + float3(0, 4.31265, 9.38974)) + v.y) + v.z);
}

float ValueNoise12(float2 src)
{
	float2 i = floor(src);
	float2 f = frac(src);

	float v1 = hash12(i + float2(0.0, 0.0));
	float v2 = hash12(i + float2(1.0, 0.0));
	float v3 = hash12(i + float2(0.0, 1.0));
	float v4 = hash12(i + float2(1.0, 1.0));

	float2 a = f * f * f * (10.0 + f * (-15.0 + f * 6.0));

	return 2.0 * lerp(
		lerp(v1, v2, a.x),
		lerp(v3, v4, a.x),
		a.y
	) - 1.0;
}

float ValueNoise13(float3 src)
{
	float3 i = floor(src);
	float3 f = frac(src);

	float v1 = hash13(i + float3(0.0, 0.0, 0.0));
	float v2 = hash13(i + float3(1.0, 0.0, 0.0));
	float v3 = hash13(i + float3(0.0, 1.0, 0.0));
	float v4 = hash13(i + float3(1.0, 1.0, 0.0));
	float v5 = hash13(i + float3(0.0, 0.0, 1.0));
	float v6 = hash13(i + float3(1.0, 0.0, 1.0));
	float v7 = hash13(i + float3(0.0, 1.0, 1.0));
	float v8 = hash13(i + float3(1.0, 1.0, 1.0));

	float3 a = f * f * f * (10.0 + f * (-15.0 + f * 6.0));

	return 2.0 * lerp(
		lerp(lerp(v1, v2, a.x), lerp(v3, v4, a.x), a.y),
		lerp(lerp(v5, v6, a.x), lerp(v7, v8, a.x), a.y),
		a.z
	) - 1.0;
}

float3 ValueNoise33(float3 src) {
	float3 i = floor(src);
	float3 f = frac(src);

	float3 v1 = hash33(i + float3(0.0, 0.0, 0.0));
	float3 v2 = hash33(i + float3(1.0, 0.0, 0.0));
	float3 v3 = hash33(i + float3(0.0, 1.0, 0.0));
	float3 v4 = hash33(i + float3(1.0, 1.0, 0.0));
	float3 v5 = hash33(i + float3(0.0, 0.0, 1.0));
	float3 v6 = hash33(i + float3(1.0, 0.0, 1.0));
	float3 v7 = hash33(i + float3(0.0, 1.0, 1.0));
	float3 v8 = hash33(i + float3(1.0, 1.0, 1.0));

	float3 a = f * f * f * (10.0 + f * (-15.0 + f * 6.0));

	return 2.0 * lerp(
		lerp(lerp(v1, v2, a.x), lerp(v3, v4, a.x), a.y),
		lerp(lerp(v5, v6, a.x), lerp(v7, v8, a.x), a.y),
		a.z
	) - 1.0;
}

float FBM13(float3 src) {
	const float3x3 M = 2.0 * float3x3(
		 0.54030231,  0.45464871,  0.70807342,
		-0.84147098,  0.29192658,  0.45464871,
		 0.0       , -0.84147098,  0.54030231);
	float ret = 0.0;
	ret += 0.5000 * ValueNoise13(src); src = mul(M, src);
	ret += 0.2500 * ValueNoise13(src); src = mul(M, src);
	ret += 0.1250 * ValueNoise13(src); src = mul(M, src);
	ret += 0.0625 * ValueNoise13(src); src = mul(M, src);
	return ret * (1.0 / 0.9375);
}

float SampleHitState(float4 worldPos) {
	float2 uv = WorldPosToHitTexturePos(worldPos).xy;
	uv = 0.5 + 0.5 * uv;
	uv += HitTextureOffset;
	return tex2Dlod(HitHistorySampler, float4(uv, 0, 0)).r;
}

float4 PerturbPosition(float4 pos, float4 worldPos) {
	if (SampleHitState(worldPos) > HitThreshold) {
		float3 noise1 = ValueNoise33(pos.xyz * PerturbFrequency);
		float  noise2 = ValueNoise12(pos.xy  * PerturbFrequency);
		pos.xyz += noise1 * PerturbMaxWidth;
		pos.y = min(pos.y * lerp(YScalingMin, YScalingMax, noise2), pos.y);
	}
	return pos;
}

float3 TangentNormalToWorldNormal(float3 tangentNormal, float3 normal, float3 pos, float2 uv) {
	float3 p1 = ddx(pos);
	float3 p2 = ddy(pos);
	float2 uv1 = ddx(uv);
	float2 uv2 = ddy(uv);

	// world空間におけるu軸とv軸の方向を求める
	float3 u = normalize(uv2.y * p1 - uv1.y * p2);
	float3 v = normalize(uv1.x * p2 - uv2.x * p1);

	// uとvをnormalを法線とする平面に射影して tangent vector と binormal vector を得る
	float3 tangent  = normalize(u - dot(u, normal) * normal);
	float3 binormal = normalize(v - dot(v, normal) * normal);

	return normalize(tangentNormal.x * tangent + tangentNormal.y * binormal + tangentNormal.z * normal);
}

float3 RandomUnitVector(float3 p) {
	float r1 = FBM13(p);
	float r2 = FBM13(p + float3(42, 12, 91)) * (2 * PI);
	float theta = acos(1 - r1 * NormalDistortionMaxAngle);
	float phi = r2;
	return float3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
}

float3 DistortNormal(
	float3 modelPos,
	float3 worldPos,
	float3 normal,
	float2 tex
) {
	if (SampleHitState(float4(worldPos, 1)) > HitThreshold) {
		normal = normalize(normal);
		float3 tangentNormal = RandomUnitVector(modelPos * NormalDistortionFrequency);
		return TangentNormalToWorldNormal(tangentNormal, normal, worldPos, tex);
	} else {
		return normal;
	}
}
float3 GetDistortion(float3 modelPos, float3 worldPos) {
	if (SampleHitState(float4(worldPos, 1)) > HitThreshold) {
		return RandomUnitVector(modelPos * NormalDistortionFrequency);
	} else {
		return float3(0, 0, 1);
	}
}

#endif
#endif
